package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.41

import (
	"context"
	"encoding/base64"
	"fmt"
	"sort"

	"github.com/IGassmann/graphql-playground/apps/api/graph/model"
)

// AllStarships is the resolver for the allStarships field.
func (r *queryResolver) Starships(ctx context.Context, after *string, first *int, before *string, last *int) (*model.StarshipConnection, error) {
	sortedStarships := make([]model.Starship, len(r.starships))
	i := 0
	for _, starship := range r.starships {
		sortedStarships[i] = starship
		i++
	}
	sort.Slice(sortedStarships, func(i, j int) bool {
		return sortedStarships[i].ID < sortedStarships[j].ID
	})

	var allEdges []*model.StarshipsEdge
	for _, starship := range sortedStarships {
		starshipNode := starship
		allEdges = append(allEdges, &model.StarshipsEdge{
			Node:   &starshipNode,
			Cursor: base64.StdEncoding.EncodeToString([]byte(starshipNode.ID)),
		})
	}

	edges, err := edgesToReturn(allEdges, before, after, first, last)
	if err != nil {
		return nil, err
	}

	var nodes []*model.Starship
	for _, edge := range edges {
		nodes = append(nodes, edge.Node)
	}

	var startCursor *string
	var endCursor *string
	if len(edges) > 0 {
		startCursor = &edges[0].Cursor
		endCursor = &edges[len(edges)-1].Cursor
	}

	return &model.StarshipConnection{
		PageInfo: &model.PageInfo{
			HasPreviousPage: hasPreviousPage(allEdges, before, after, first, last),
			HasNextPage:     hasNextPage(allEdges, before, after, first, last),
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
		Edges:      edges,
		Nodes:      nodes,
		TotalCount: intPtr(len(r.starships)),
	}, nil
}

// Starship is the resolver for the starship field.
func (r *queryResolver) Starship(ctx context.Context, id string) (*model.Starship, error) {
	if s, ok := r.starships[id]; ok {
		return &s, nil
	}
	return nil, nil
}

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id string) (model.Node, error) {
	panic(fmt.Errorf("not implemented: Node - node"))
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func edgesToReturn(allEdges []*model.StarshipsEdge, before *string, after *string, first *int, last *int) ([]*model.StarshipsEdge, error) {
	edges, err := applyCursorsToEdges(allEdges, before, after)
	if err != nil {
		return nil, err
	}

	if first != nil {
		if *first < 0 {
			return nil, fmt.Errorf("first must be positive")
		}
		if len(edges) > *first {
			// Slice edges to be of length first by removing edges from the end of edges.
			edges = edges[:*first]
		}
	}

	if last != nil {
		if *last < 0 {
			return nil, fmt.Errorf("last must be positive")
		}
		if len(edges) > *last {
			// Slice edges to be of length last by removing edges from the start of edges.
			edges = edges[len(edges)-*last:]
		}
	}

	return edges, nil
}
func applyCursorsToEdges(allEdges []*model.StarshipsEdge, before *string, after *string) ([]*model.StarshipsEdge, error) {
	edges := allEdges

	var afterEdge *model.StarshipsEdge
	if after != nil {
		var afterIndex int
		for i, edge := range allEdges {
			if edge.Cursor == *after {
				afterIndex = i
				break
			}
		}
		afterEdge = edges[afterIndex]

		if afterEdge != nil {
			// Remove all elements of edges before and including afterEdge.
			edges = edges[afterIndex+1:]
		}
	}

	var beforeEdge *model.StarshipsEdge
	if before != nil {
		var beforeIndex int
		for i, edge := range allEdges {
			if edge.Cursor == *before {
				beforeIndex = i
				break
			}
		}

		beforeEdge = allEdges[beforeIndex]

		if beforeEdge != nil {
			// remove all elements of edges after and including beforeEdge.
			edges = edges[:beforeIndex]
		}
	}

	return edges, nil
}
func hasPreviousPage(allEdges []*model.StarshipsEdge, before *string, after *string, first *int, last *int) bool {
	if last != nil {
		edges, err := applyCursorsToEdges(allEdges, before, after)
		if err != nil {
			return false
		}

		if len(edges) > *last {
			return true
		} else {
			return false
		}
	}

	return false
}
func hasNextPage(allEdges []*model.StarshipsEdge, before *string, after *string, first *int, last *int) bool {
	if first != nil {
		edges, err := applyCursorsToEdges(allEdges, before, after)
		if err != nil {
			return false
		}

		if len(edges) > *first {
			return true
		} else {
			return false
		}
	}

	return false
}
